计算机基础知识

计算机体系结构-CPU

CU:控制单元，分析指令，给出控制信号
指令寄存器，存放当前执行的指令

IR:指令寄存器，存放当前执行的指令

PC:程序计数器，存放下一条指令地址，有自动加1功能。

AR:地址寄存器，保存当前CPU所访问的内存单元地址

ID:指令译码器，对操作码进行分析。

取指令 分析指令 执行指令



运算器:用于实现算术运算(如:加减乘除)、逻辑运算(如:与或非)

ACC：累加器，用于存放操作数，或运算结果。

MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。

X:通用的操作数寄存器，用于存放操作数。

ALU:算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算，

DR:数据缓存寄存器。

PSW:状态条件寄存器，用来保存指令运行标志

循环冗余校验码

设生成[多项式]

根据最高次幂高位左移，低位补零

对移位后的信息码，用生成多项式进行模2除法，产生余数，余数为校验位

CRC码：信息位+校验位

奇偶校验

奇校验:被传输的有效数据中“1”的个数是奇数个，校验位填“0”，否则填“1”;
偶校验:被传输的有效数据中“1”的个数是偶数个，校验位填“0”否则填“1”

奇校验1000110(0)
偶校验:1000110(1)

使用一位奇偶校验的方法能够检测出一位错误，但无法判断是哪一位出错。
当发生两位同时出错的情况时，奇偶校验也无法检测出来。所以奇偶校验常用于对少量数据的校验，如一个字节。

海明码

海明码的构成方法是:在数据为之间插入k个校验码，通过扩大码距来实现讲错和纠错。

公式：2^r >= k + r + 1

r：校验位的个数

m：信息位的个数



原码:用数值部分表示真值的绝对值，符号位“0/1”对应“正/负”

反码：正数的反码与原码一样，负数数据位取反

补码：负数的补码 =反码末位+1(要考虑进位)，正数的补码等于原码

移码: 补码的基础上将符号位取反。注意:移码只能用于表示整数



![image-20240904155510142](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240904155510142.png)



指令系统一指令格式

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。

一条指令通常要包括操作码字段和地址码



指令系统——指令的流水处理

指令控制方式有顺序方式、重看方式和流水方式三种

流水方式:是指并行性或并发性嵌入计算机系统里的一种形式，它把重复的顺序处理过程分解为若干子过程，每个子过程能在专用的独立模块上有效地并发工作。

## 指令系统——流水线的计算

流水线周期为执行时间最长的一段

流水线的计算公式为：1条指令执行时间+（指令条数-1）*流水线周期

例:若指令流水线把一条指令分为取指、 分析和执行三部分,且三部分的时间分别是取指2ns,分析2ns,执行1ns。

## 指令系统——流水线的吞吐率

流水线的吞吐率(Though Put rate,TP):是指在单位时间内流水线所完成的任务数量或输出的结果数量。

计算流水线吞吐率基本公式：

![image-20240904145532495](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240904145532495.png)

## 指令系统——流水线的加速比

![image-20240904151222619](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240904151222619.png)

## 计算机体系结构——Flynn分类法

SISD：单指令流单数据流

SIMD：单指令流多数据流

特性：各处理器以异步的形式执行同一条指令

MISD：多指令流单数据流

特性：被证明不可能，至少是不实际

MIMD：多指令流多数据流

特性：能够实现作业任务、指令等各级全面并行

指令系统——CISC和RISC

指令系统——寻址方式(数据寻址)

立即寻址:操作数作为指令的一部分直接写在指令中，这种操作数称为立即数。

寄存器寻址: 指令所要的操作数已存储在某寄存器中，或把目标操作数存入寄存器

直接寻址:指令所要的操作数存放在内存中，在指令中直接给出该操作数的有效地址，

寄存器间接寻址:操作数在存储器中，操作数的有效地址用S1、D1、BX和BP四个寄存器之一来指定。

寄存器相对寻址:操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)或变址寄存器(SI、DI)的内容和指令中的8位/16位偏移量之和。

基址加变址寻址方式:操作数在存储器中，其有效地址是-一个基址寄存器(BX.BP)和一个变址寄存器(S、DI)的 内容之和。

相对基址加变址寻址:操作数在存储器中,其有效地址是一个基址寄存器(BX.BP)的值、一个变址寄存器(S1、DI)的值和指令中的8位/16位偏移量之和。

## CPU与外设之间的数据传送方式:

1、直接程序控制方式

直接程序控制方式是指在完成数据的输入/输出中，整个输入/输出过程是在CPU执行程序的控制下完成的。这种方式还可以分为以下两种:(1)无条件传送方式:无条件地与CPU交换数据。(2)程序查询方式:先通过CPU查询外设状态，准备好之后再与CPU交换数据

2、中断方式

3、直接存储器存取方式

直接存储器存取(Direct Memory Access， DMA)方式是在存储器与I/O设备间直接传送数据，即在内存与I/0设备之间传送一个数据块的过程中，不需要CPU的任何干涉，是-种完全由D№A硬件完成I/O操作的方式。

# 存储系统

## 主存储器

存储单元:每个存储单元存放一串二进制代码。

存储字(word):存储单元中二进制代码的组合

存储字长:存储单元中二进制代码的位数。

存储元:即存储二进制的电子元件，每个存储元可存1bit。

MAR：地址寄存器

MDR:数据寄存器

MAR=4位-总共有 2\*2\*2*2个存储单元

MDR=16位一每个存储单元可存放16bit，1个字(word)=16bit

## 存储系统的层次结构

主存一辅存:实现虚拟存储系统，解决了主存容量不够的问题。

Cache一主存:解决了主存与CPU速度不匹配的问题。

Cache一主存层：硬件自动完成


主存一辅存层：硬件+操作系统



## 存储系统——存储器的分类

读/写存储器(RAM)它指既能读取数据也能存入数据的存储器

只读存储器(ROM)工作过程中仅能读取的存储器。



## 存储系统——硬盘

存取时间 = 寻道时间 +等待时间(平均定位时间+转动延迟)

寻道时间是指磁头移动到磁道所需的时间

等待时间为等待读写的扇区转到磁头下方所用的时间

# 计算机系统

## 死锁

死锁产生的必要条件

互斥条件: 一个资源每次只能被一个进程使用

占有且等待:一个进程因请求资源而阻塞时，对已获得的资源保持不放

不可强行占有: 进程已获得的资源，在末使用完之前，不能强行剥夺

循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系

判断死锁的公式

R为一个进程所需要的资源

R(i-1)<=可用系统资源

信号量S为负数，表示有进程在等待，所以资源可用数量肯定为0，-2表示有2个进程在等待

## PV操作

P就是wait操作，等待资源，V就是++操作，释放资源

信号量的值=这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）

P(S)——申请一个资源S，如果资源不够就阻塞等待

V(S)——释放一个资源S，如果有进程在等待该资源，则唤醒一个进程

![image-20240923200922615](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240923200922615.png)

## 位示图

某字长位32位的计算机的文件管理系统采用位示图（bitmap）记录磁盘的使用情况。若磁盘的容量为300GB，物理块的大小为1MB，那么位示图的大小为（9600）字。

位示图表示的是磁盘情况，一个磁盘对应一个比特位来记录
磁盘总容量为300GB，也就是磁盘块大小为300GB
每一个物理块大小是1MB
则可以求出磁盘块的数量=300GB/1MB，1GB和1MB之间转换是210，则磁盘块的数量=300GB/1MB=300×210
也就是需要300×210个比特位来表示位示图

问一共需要多少个字？
题目中告知字长位32位的计算机，所以需要的字=300×210/32=300×210/25=300×32=9600



可靠性位示图如下，求2048号，它所占据的字号和位号。

![image-20240923202551016](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240923202551016.png)

图中的位示图的宾浩是从0还是从1开始，设计到后续计算是否需要+1-1的操作

图中的字号和位号都是0开始的，因此需要考虑+1-1操作

2048号，是2049个磁盘，这个磁盘每32个比特位占据一个字，2049需要的字为=2049/32=64…1，也就是64余1
表示放在第64个字的时候，放不下了，因此需要放在第65个字的位置，第65个字的编号为64。

## 字节编码

已知主存容量为16MB,且按①,求该主存地址至少需要多少位

字节编址就是8位的意思,所以16MB=(16*1024)KB=(16*1024*1024)byte=24*210*210=224 byte.所以需要24位

先将编址方式凑成8位，即2*4位，相应的主存容量也扩充2倍为32MB，所以32MB=(32*1024)KB=(32*1024*1024)byte=25*210*210=225byte.所以需要25位

计算机系统的可靠性是指从它开始运行(t=0)到某个时刻t这段时间内能正常运行的概率，用R(t)表示。

串联部件的可靠度=各部件的可靠度的乘积。

并联部件的可靠度=1-部件失效率的乘积。

# 面向对象

## UML图形

### 用例图

用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。它以图形化的方式将系统描述成用例、参与者及其之间的关系。用例图在高层交流了系统必须处理的业务事件的范围，是描述系统与其他外部系统以及用户之间交互的图形。发起或触发用例的外部用户称为参与者。为了完成某些业务任务，参与者发起系统活动，即用例。在构建用例图时，常用的方式是先识别参与者，然后确定用例以及用例之间的关系。

![image-20240925125656879](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240925125656879.png)

### 部署图

![image-20240925125741199](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240925125741199.png)

### 组件图

组件图是用来反映代码的物理结构。从组件图中，您可以了解各软件组件（如源代码文件或动态链接库）之间的编译器和运行时依赖关系。使用组件图可以将系统划分为内聚组件并显示代码自身的结构。

![image-20240925125805940](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240925125805940.png)

### 类图

类图是类的结构及类之间关系的一种表现形式。

![image-20240925125835572](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240925125835572.png)

### 状态图

状态图以实心圆表示起点，圆形内嵌圆点表示终点，圆角矩形表示状态，连接线表示事件。

![image-20240925125930097](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240925125930097.png)

## 多级索引

一级间接地址索引

一级索引块（磁盘索引块）占1KB、一个地址项占4B，则一级索引块能存储：

1KB/4B = 256块，磁盘数据块

二级间接地址索引

二级间接地址索引首先指向一个包含一级间接索引的磁盘块，每个一级间接索引再指向一个包含直接地址索引的磁盘块，而每个直接地址索引最终指向一个存储数据的磁盘块。

## 数据元素和数据项

数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。

短路运算的原理：当有多个表达式时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值

## 二叉树算术表达式

由左子树往右子树，先乘除括号后加减运算

![image-20240922195827350](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240922195827350.png)

# 软件工程

## 软件项目活动

1、关键路径（最少时间）：从开始到结束得所有路径中，所花时间最长的一条为关键路径；
2、最早开始时间：在关键路径上，从开始到该任务的最早执行的时间；
3、最晚开始时间：关键路径的总时间-反向得出该任务的时间；
4、松弛时间（最多延迟执行的时间）： 关键路径的总时间－包含该任务的关键路径花的时间；

![image-20240922195348953](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240922195348953.png)

# 软件测试

## 软件开发模型

瀑布模型（需求比较明确的软件项目。）

瀑布模型的特点是：软件开发的阶段划分是明确的，一个阶段到下一个阶段有明显的界线。在每个阶段结束后，都会有固定的文档或源程序流入下一阶段。如在需求分析阶段结束后，需要有明确的描述软件需求的文档。因此也称瀑布模型是面向文档的软件开发模型。图中向上的虚线箭头表示当前阶段出现问题后需要反馈到上一阶段去修正。

优点：

a)当软件需求明确，稳定时，可以按部就班地开发软件。

b)各个阶段的人员只专注于自己的开发任务，可以提高阶段效率。

缺点：

a)软件需求不明确或变动剧烈时，要到测试阶段才会暴露出需求的缺陷，造成后期修改代价太大难以控制开发的风险。

b)软件开发前期造成的问题对后期影响较大。



V模型（V模型适用于需求明确和需求变更不频繁的情形。
车企和银行软件开发用的比较多。）

V模型的中心思想是，研发人员和测试人员需要同时工作，在软件做需求分析的同时就会有测试用例的跟踪，这样可以尽快找出程序错误和需求偏离，从而更高效的提高程序质量，最大可能的减少成本，同时满足用户的实际软件需求。

优点：

a)提供了明确的开发过程，使团队能够更好地掌握整个开发过程，并能够更好地管理和控制。

b)强调测试和验证的重要性，确保软件质量和可靠性。通过测试和验证，团队可以更早地发现和解决问题，从而降低风险。

c)强调可追溯性，每个开发阶段都应该与相应的测试阶段相对应，并能够追溯到需求和设计文档。
缺点：

a)需求发生变更，需要重新回到前期规划阶段，这会增加开发时间和成本。

b)需要大量的文档和工作量，包括需求文档、设计文档、测试计划和测试报告等。这些文档和工作量可能会增加开发时间和成本。

c)测试阶段非常重要，需要测试人员具备良好的技能和经验。测试人员的技能和经验不足，可能会影响测试结果和软件质量。

增量模型（a)整个项目开发过程中，需求都可能发生变化，客户接受分阶段交付。
b)分析设计人员对应用领域不熟悉，难以一步到位。
c)中等或高风险项目。）

客户对每一个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程的每一个增量发布后不断重复，直到产生了最终的完善产品。增量模型强调每一个增量均发布一个可操作的产品。采用增量模型的软件过程如下图。

例如：
对于一个软件项目，具有A，B，C，D4个功能，先开发出功能A，B，然后再开发出功能C，D，进而完成整个项目功能的开发，即AB->CD->ABCD。

优点：

a)前期开发人员可以较少。这时可开发出核心功能产品，投入市场，如果口碑不错，可以为下一个增量投入更多的人力。

b)规避技术风险。如一个系统需要用到的部件暂时未到，可以在早期增量中避免使用这个部件，后续增量再增加即可。

缺点：

a)由于需要实现的功能是一步步并入现有软件体系结构的，这要求软件体系结构有较好的柔韧性和开放性，便于功能的修改和添加。

b)软件结构可能随着需求的变更变得越来越糟。

迭代模型（a)项目开发早期需求可能有所变化。
b)分析设计人员对应用领域很熟悉。
c)高风险项目。）

对于一个软件项目，具有A，B，C，D4个功能，先同时做出A，B，C，D四个功能的原型，然后完成它们的基本功能，由粗到细，逐步求精，接着对这些功能进行优化，最终得到功能完整的软件，即ABCD基本功能->ABCD全部功能。

优点：

a)开发人员重复某个迭代，损失只是这个开发有误的迭代的花费。

b)降低了产品无法按照既定进度进入市场的风险。通过在开发早期就确定风险，可以尽早来解决而不至于在开发后期匆匆忙忙。

c)加快了开发工作的进度，因为开发人员清楚问题的焦点所在，他们的工作会更有效率。

d)由于用户的需求并不能在一开始就作出完全的界定，它们通常是在后续阶段中不断细化的。因此，迭代过程这种模式使适应需求的变化会更容易些。

缺点：

a)需求在项目早期开发可能有所变化，需要有一个高素质的项目管理者和一个高技术水平的开发团队。

快速原型模型

增量模型的另一种形式；在开发真实系统之前，构造一个原型，在该原型的基础上，逐渐完成整个系统的开发工作。

优点

克服瀑布模型的缺点，减少由于软件需求不明确带来的开发风险。

缺点

所选用的开发技术和工具不一定符合主流的发展；快速建立起来的系统结构加上连续的修改可能会导致产品质量低下。

## CMMI等级

![image-20240925111442973](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240925111442973.png)

## IEC 9126模型特性

![image-20240925112014394](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240925112014394.png)

## 模块设计注意

![image-20240925112141078](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240925112141078.png)

![image-20240925112218956](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240925112218956.png)

## McCabe度量方法计算程序复杂度

方法一

强连通图公式：V(G)=m−n+2p

m 是图 G 中弧的个数，n 是图 G 中的结点数，p 是图 G 中的强连通分量个数。

方法二

流图中判定结点的数目+1

判定结点,是指有分支结点,某结点有两个分支算一个判定结点,多余两个分支,算(分支数-1)个判定节点

# 数据结构

## 串

（1）空串:长度为零的串，空串不包含任何字符。

(2)空格串:由一个或多个空格组成的串。含有子串的串

(3)子串:由串中任意长度的连续字符构成的序列。含有子串的串称为主串。子串在主串中的位置指子串首次出现时，该子串的第个字符在主串中的位置。空串是任意串的子串。

(4)串相等:指两个串长度相等且对应位置上的字符也相同。

(5)串比较:两个串比较大小时以字符的ASCI码值作为依据。比较操作从两个串的第一个字符开始进行，字符的ASCII码值大者所在的串为大;若其中一-一个串先结束，则以串长较大者为大。

## 串的存储结构

（1）串的顺序存储:定长存储结构
(2)串的链式存储:块链

子串的定位操作通常称为串的模式匹它是各种串处理系统中最重要的运算之一。子串也称为模式串

## 数组——数组的地址计算

### 一维数组：

```
a[i]的存储地址为:a+i*len
//len为元素占字节大小
```

二维数组：

```
二维数组a[m][n]
a[i][j]的存储地址(按行存储)为:a+(i*n+j)*len
a[i][j]的存储地址(按列存储)为:a+(j*m+i)*len
//len为元素占字节大小
```

## 矩阵

## 广义表

取表头：Head

取表尾：Tail

求表头：及表中的第一个元素

求表尾：及除表第一个元素的剩余表需要加上一个括号

表的长度：所包含的元素个数

表的深度：括号的最大层次

## 线性表

顺序存储在读操作时优于链式存储

链式存储在删除和插入操作优顺序存储

栈和队列

队列是一种先进先出(FIFO)的线性表，它只允许在表的一端插入元素，分在表的另一端删除元系。在队列中，允许插入元素的--端称为队尾(Rear)，允许删除元素的--端称为队头(Front)。

队空条件:head=tail

队满条件:(tail+1)%size=head

## 二叉排序树

1. 对于根节点，左子树中所有节点的值<根节点的值<右子树中所有节点的值。

2. 任意节点的左、右子树也是二叉搜索树，即同样满足条件1.。

   ![image-20240922164052048](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240922164052048.png)
   
   ## 图
   
   对于连通图，从某个顶点出发，可以到达其余任意顶点。
   
   对于非连通图，从某个顶点出发，至少有一个顶点无法到达。
   
   强连通图：在有向图中, 若对于每一对顶点v1和v2, 都存在一条从v1到v2和从v2到v1的路径,则称此图是强连通图。
   
   弱连通图：将有向图的所有的有向边替换为无向边，所得到的图称为原图的基图。如果一个有向图的基图是连通图，则有向图是弱连通图。
   
   邻接矩阵特性
   
   顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义。
   对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称。
   将邻接矩阵的元素从1和0替换为权重，则可表示有权图。
   
   ### 广度优先遍历
   
   广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张。
   
   ### 深度优先遍历
   
   深度优先遍历是一种优先走到底、无路可走再回头的遍历方式。

## 排序

### 选择排序

开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。两个指针i为有序区间的下一个元素索引，k为每轮的最小元素。

时间复杂度为𝑂(𝑛2)、非自适应排序

空间复杂度为𝑂(1)、原地排序

### 冒泡排序

冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大
小，如果“左元素>右元素”就交换二者。遍历完成后，最大的元素会被移动到数组的最右端。

冒泡排序的最差时间复杂度和平均时间复杂度仍为𝑂(𝑛2)；但当输入数组完全有序时，可达到
最佳时间复杂度𝑂(𝑛)。

空间复杂度为𝑂(1)、原地排序

稳定排序：由于在“冒泡”中遇到相等元素不交换。

### 插入排序

具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。

时间复杂度为𝑂(𝑛2)、自适应排序

空间复杂度为𝑂(1)、原地排序

稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。

### 快速排序

是一种基于分治策略的排序算法，运行高效，应用广泛。

快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。

1. 选取数组最左端元素作为基准数，初始化两个指针i和j分别指向数组的两端。
2. 设置一个循环，在每轮中使用i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两元素。
3. 循环执行步骤2.，直到i和j相遇时停止，最后将基准数交换至两个子数组的分界线。

时间复杂度为𝑂(𝑛log𝑛)、自适应排序，最差情况为o(n2)

空间复杂度为𝑂(𝑛)、原地排序

非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。

### 归并排序

是一种基于分治策略的排序算法

1. 划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。
2. 合并阶段：当子数组长度为1时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。

![image-20240922154428293](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240922154428293.png)

时间复杂度为𝑂(𝑛log𝑛)、非自适应排序

空间复杂度为𝑂(𝑛)、非原地排序

 稳定排序：在合并过程中，相等元素的次序保持不变。

### 堆排序

是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和
“元素出堆操作”实现堆排序。

1. 输入数组并建立大顶堆。完成后，最大元素位于堆顶。

2. 将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减1，已排序元
    素数量加1。

3. 从堆顶元素开始，从顶到底执行堆化操作（siftdown）。完成堆化后，堆的性质得到修复。

4. 循环执行第2步和第3步。循环𝑛−1轮后，即可完成数组排序。

   时间复杂度为𝑂(𝑛log𝑛)、非自适应排序

   空间复杂度为𝑂(1)、原地排序

   非稳定排序：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。

「小顶堆minheap」：任意节点的值≤其子节点的值。
「大顶堆maxheap」：任意节点的值≥其子节点的值。

![image-20240922160424950](C:\Users\kjh\AppData\Roaming\Typora\typora-user-images\image-20240922160424950.png)

### 动态规划

1）最优子结构性质
当问题的最优解包含其子问题的最优解时，称该问题具有最优子结构性质。

要证明原问题具有最优子结构性质，通常采用反证法。假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在该假设下可构造出比原问题的最优解更好的解，从而导致矛盾。

2）子问题重叠性质
子问题重叠性质是指由原问题分解出的子问题不是相互独立的，存在重叠现象。

### 分治

将一个难以直接解决的大问题，分割成k个规模较小的子问题，这些子问题相互独立，且与原问题相同，然后各个击破，分而治之。

分治法常常与递归结合使用：通过反复应用分治，可以使子问题与原问题类型一致而规模不断缩小，最终使子问题缩小到很容易求出其解，由此自然导致递归算法。

分治与动态规划的区别对于子问题进行多次求解

这种情况下若用分治法会对一些子问题进行多次求解，这显然是不必要的。

### 贪心

当一个问题具有最优子结构性质时，可用动态规划法求解。但有时会有比动态规划更简单更直接效率更高的算法——贪心法。贪心法总是做出在当前看来最好的选择，也就是说贪心法并不从整体最优考虑，它所做出的选择只是在某种意义上的 局部最优 选择。虽然贪心法并不能对所有问题都得到整体最优解，但是对许多问题它能产生整体最优解。有些情况下，贪心法虽然不能得到整体最优解，但其最终结果却是最优解的很好的近似。

与动态规划法的区别
贪心问题的整体最优解可通过一系列局部的最优选择，即贪心选择来达到。这也是与动态规划的主要区别。
在动态规划中，每步所做出选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。
在贪心法中，仅做出当前状态下的最好选择，即局部最优选择。然后再去解做出这个选择之后产生的相应的子问题。贪心法所做出的贪心选择可以依赖于以往所做过的选择，但绝不依赖于将来所做的选择，也不依赖于子问题的解。
正是由于这种差别，动态规划通常以自底向上的方式解各子问题，而贪心法通常以自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做出一次贪心选择就将所求问题简化为规模更小的子问题。

### 回溯法

回溯法是对问题的解空间树进行深度优先搜索 ，但是在对每个节点进行DFS之前，要先判断该节点是否有可能包含问题的解。如果肯定不包含，则跳过对以该节点为根的子树的搜索，逐层向其祖先节点回溯。如果有可能包含，则进入该子树，进行DFS。



